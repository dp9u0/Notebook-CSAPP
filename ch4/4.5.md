# Y86-64 流水线

针对之前的SEQ顺序架构,做以下调整使之成为一个性能有所提升的流水线设计:

## SEQ+

PC计算从上一个指令的最后调整到当前指令的最开始

## 插入流水线寄存器

增加流水线寄存器(硬件):

* F : 保存程序计数器预测值(由PC增加计算得到)
* D : 取指结果
* E : 译码指令和寄存器值
* M : 执行结果以及CC
* W : 反馈路径写回,以及ret地址

```s
irmovq $1,%rax
irmovq $2,%rbx
irmovq $3,%rcx
irmovq $4,%rdx
halt
```

![流水线寄存器](./img/4.5.01.png)

需要注意的是: Select A 块 : 由于 valP只有在call和jXX时会使用,并且在这两个指令中不会使用valA因此可以用寄存器的这一部分valA 通过Select A选取数据携带带使用的地方,这样就可以减少连线

## 预测下一阶段PC

* 除了 jXX ret call外,总是可以确定下一个PC的值(valP).
* call jmp 下一个PC是 valC
* jXX 可能是 valC 也可能是 valP 既可以预测选择了分支,也可以预测没有选择分支,最简单的策略,一般倾向于预测选择了分支(实际中会更加复杂)

上面的图中 Predict PC 块负责预测下一个PC的值并更新到 F_predPC

## 流水线冒险

流水线上的不同指令之间读写程序寄存器,程序计数器,内存,条件码寄存器,状态寄存器的先后顺序不一致,会导致流水线冒险.即读到的不是期望的值.

可以通过以下方式处理冒险的情况:

### 暂停

出现冒险的指令前插入气泡 (*bubble*)

### 转发

增加连线可以将先执行的指令中某个阶段的值转发到后执行的指令的某个阶段

![转发](./img/4.5.03.png)

### 加载/使用

前一个指令读取(一般是读取内存)还没有进行,下一个指令已经到了执行阶段需要这个值,因此只是转发是无法解决的,需要暂停+转发

### 避免控制冒险

当遇到分支or `ret` 时,插入气泡消除可能出现的错误指令

![避免控制冒险](./img/4.5.04.png)

## 异常处理

* 流水线最深的指令引发异常优先级越高
* 应该避免由于错误的分支预测引发的异常
* 流水线上的指令在发生异常后改变了状态
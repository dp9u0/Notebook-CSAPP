# 过程调用

封装代码,接收一组参数和提供一个返回值.

## 运行时栈

过程调用使用栈结构提供 __先进后出__ 的内存管理方式.

下图是过程P调用过程Q时栈的情况.需要注意的是栈是从高地址向低地址增长的.

![堆栈结构](./img/3.06.1.png)

## 转移控制

* call
* ret

```c
#include <stdio.h>

long leaf(long y)
{
    return y + 2;
}

long top(long x)
{
    long result = leaf(x - 5);
    return result + result;
}

int main()
{
    top(100);
    return 0;
}
```

```s
         .file   "3.06.1.c"
        .text
        .globl  leaf
        .type   leaf, @function
leaf:
.LFB0:
        .x is in %rdi
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movq    %rdi, -8(%rbp)
        movq    -8(%rbp), %rax
        addq    $2, %rax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   leaf, .-leaf
        .globl  top
        .type   top, @function
top:
.LFB1:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $24, %rsp
        movq    %rdi, -24(%rbp)
        movq    -24(%rbp), %rax
        subq    $5, %rax
        movq    %rax, %rdi
        call    leaf
        movq    %rax, -8(%rbp)
        movq    -8(%rbp), %rax
        addq    %rax, %rax
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE1:
        .size   top, .-top
        .globl  main
        .type   main, @function
main:
.LFB2:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        movl    $100, %edi
        call    top
        movl    $0, %eax
        popq    %rbp
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE2:
        .size   main, .-main
        .ident  "GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609"
        .section        .note.GNU-stack,"",@progbits
```

## 数据传送

* 当P调用Q时,P必须把参数复制到对应的寄存器中
* 当Q的参数超过7个时,则需要利用栈,将1-6号参数复制到寄存器,7-n号寄存器复制到栈中
* 当使用栈传递参数时候,所有数据大小都向8的倍数对齐.
* 当Q需要访问参数时,直接访问寄存器,或者 从 8(%rsp) 向上访问
* 当调用返回前,Q需要负责把返回值复制到 %rax 寄存器中.

![数据传送-参数](./img/3.06.2.png)

```c
void proc(long x1, long *x2p, int x3, int *x4p, short x5, short *x6p, char x7, char *x8p)
{
    *x2p += x1;
    *x4p += x3;
    *x6p += x5;
    *x8p += x7;
}
```

```s
proc:
.LFB0:
        .cfi_startproc
        movq    16(%rsp), %rax //x8p(指针是64bit，占用8个地址) -> %rax
        addq    %rdi, (%rsi)
        addl    %edx, (%rcx)
        addw    %r8w, (%r9)
        movl    8(%rsp), %edx // x7 -> %edx
        addb    %dl, (%rax)
        ret
        .cfi_endproc
.LFE0:
```

## 局部存储

### 栈上局部存储

### 寄存器上的局部存储空间

## 递归过程